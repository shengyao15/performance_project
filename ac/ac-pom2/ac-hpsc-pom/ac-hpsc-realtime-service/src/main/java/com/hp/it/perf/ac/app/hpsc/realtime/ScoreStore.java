package com.hp.it.perf.ac.app.hpsc.realtime;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

import com.hp.it.perf.ac.common.realtime.GranularityType;
import com.hp.it.perf.ac.common.realtime.RealTimeBean;
import com.hp.it.perf.ac.common.realtime.ValueType;

public class ScoreStore {

	private final static Map<Integer, RealTimeBean> latestScore = new ConcurrentHashMap<Integer, RealTimeBean>();

	private final static Map<Integer, Long> latestStartTime = new ConcurrentHashMap<Integer, Long>();

	static {
		// initStore();
	}

	// id is generated by "valueType", "granulityType", "category",
	// "featureType", can use the help class RealTimeIdHelper to generate it.
	public synchronized static void put(int id, RealTimeBean value) {
		latestScore.put(id, value);
	}

	public static RealTimeBean get(int id) {
		if (latestScore.containsKey(id))
			return latestScore.get(id);
		return null;
	}

	public static Map<Integer, RealTimeBean> getAllScore() {
		return latestScore;
	}

	public static Map<Integer, Long> getAllStartTime() {
		return latestStartTime;
	}

	@SuppressWarnings("unused")
	private static void initStore() {
		System.out.println("initStore...");

		final ExecutorService threadpool = Executors
				.newSingleThreadExecutor(new ThreadFactory() {

					@Override
					public Thread newThread(Runnable r) {
						Thread localThread = new Thread(r);
						localThread.setDaemon(true);
						return localThread;
					}
				});

		threadpool.submit(new Runnable() {
			@Override
			public void run() {
				while (true) {

					ScoreStore.put(GranularityType.Minute.getIndex(),
							new RealTimeBean(GranularityType.Minute.getIndex(),
									1, 1, ValueType.Score.getIndex(), 10086,
									(int) (Math.random() * 100)));

					try {
						Thread.sleep((long) (Math.random() * 10000));
					} catch (InterruptedException ie) {
						ie.printStackTrace();
					}
				}
			}
		});
		threadpool.shutdown();
	}

	public static void updateLatestStartTime(
			Map<Integer, Long> granularityLatestStartTime) {
		if (granularityLatestStartTime != null) {
			for (Integer id : granularityLatestStartTime.keySet()) {
				latestStartTime.put(id, granularityLatestStartTime.get(id));
			}
		}

	}

	public static Long getLatestStartTime(int granularity) {
		if (latestStartTime.containsKey(granularity)) {
			return latestStartTime.get(granularity);
		}
		return null;
	}
}
