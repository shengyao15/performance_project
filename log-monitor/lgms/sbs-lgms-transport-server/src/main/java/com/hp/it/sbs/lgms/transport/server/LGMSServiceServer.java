package com.hp.it.sbs.lgms.transport.server;

import ch.qos.logback.core.util.Loader;

import com.hp.it.sbs.core.server.TransportServerImplementation;
import com.hp.it.sbs.core.server.beans.ServiceAPI;
import com.hp.it.sbs.core.server.beans.ServiceHealthCheck;
import com.hp.it.sbs.core.server.beans.ServicePerformanceSummary;
import com.hp.it.sbs.core.server.beans.ServiceRequest;
import com.hp.it.sbs.core.server.beans.ServiceResourceData;
import com.hp.it.sbs.core.server.beans.ServiceResponse;
import com.hp.it.sbs.core.server.beans.ServiceStatusData;
import com.hp.it.sbs.core.server.logging.LogInitializer;
import com.hp.it.sbs.core.server.security.TrustStoreManager;
import com.hp.it.sbs.core.shared.exceptions.ServiceStandardErrorCodes;
import com.hp.it.sbs.core.shared.utility.ServiceClientLocator;

import java.io.IOException;
import java.io.InputStream;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

import java.net.URL;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;

import org.apache.commons.io.IOUtils;

import org.jboss.resteasy.annotations.Form;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * LGMS Service Server
 * Service Category:      LGMS
 * Generated By:          sbs-generator
 * Service Version:       1.0.0-SNAPSHOT
 * Core Version:          1.1.2
 * I-Processor Version:   2.1.5
 *
 * This class is generated based upon the Common API.
 * The versions listed above were utilized in the process.
 * These may be snapshots instead of actual releases during development.
 */
@Path("/")
public class LGMSServiceServer extends TransportServerImplementation 
{
	/** Service Category */
	private static final String SERVICE_CATEGORY = "LGMS";

	/** Service Logger */
	private static final Logger SERVICELOG = LoggerFactory.getLogger(LGMSServiceServer.class);

	/** Service Version: Major */
	private static final String VERSION_MAJOR = "1";
	
	/** Service Version: Minor */
	private static final String VERSION_MINOR = "0";
	
	/** Service Version: Incremental */
	private static final String VERSION_INCREMENTAL = "0";
	
	/** Whether the Service's Logger was initialized */
	private static boolean serviceLogInitialized;
	
	
	
	/** Access Control Group: SBS-LGMS-ADMIN */
	private static final String ACG_ADMIN = "SBS-LGMS-ADMIN";
	
	
	
	/** Class Name: Client Authentication Object */
	private static final String CLASSNAME_CLIENT_AUTHENTICATION = "com.hp.it.sbs.core.client.beans.ServiceAuthentication";
	
	
	
	/** String Literals: EXCEPTION_PERIOD - message response for invalid value for period when calling performanceCheck( ) */
	private static final String EXCEPTION_PERIOD = "The filter 'period' may only be set to 1, 5, 15, 30, or 60 minutes";
	
	/** String Literals: EXCEPTION_NOCLIENTS - log message when no client dependencies exist for health checks */
	private static final String EXCEPTION_NOCLIENTS = 
			"Could not instantiate ServiceAuthentication at runtime.  No client dependencies exist.";
	
	
	
	/** String Literals: LOGFILE_NAME - naming convention for the log configuration file */
	private static final String LOGFILE_NAME = "logback-LIFECYCLE.xml";
	
	/** String Literals: LOGFILE_NAME - naming convention for the log configuration file */
	private static final String LOGFILE_LIFECYCLE = "LIFECYCLE";
	
	
	
	/** MIME Type Literal: application/json */
	private static final String MIME_APPLICATION_JSON = "application/json";
	
	
	
	/** Method Literal: healthCheck */
	private static final String METHOD_HEALTHCHECK = "healthCheck";
	
	/** Method Literal: healthCheckShallow */
	private static final String METHOD_HEALTHCHECKSHALLOW = "healthCheckShallow";
	
	/** Method Literal: resourceCheck */
	private static final String METHOD_RESOURCECHECK = "resourceCheck";
	
	/** Method Literal: performanceCheck */
	private static final String METHOD_PERFORMANCECHECK = "performanceCheck";
	
	/** Method Literal: getServiceAPI */
	private static final String METHOD_GETSERVICEAPI = "getServiceAPI";
	
	/** Method Literal: getCoreSBSStats */
	private static final String METHOD_GETCORESBSSTATS = "getCoreSBSStats";
	
	
	
	/** System Property: Service Version */
	private static final String PROPERTY_SERVICE_VERSION = "sbs.LGMS.version";
	
	/** System Property: Service Logging Level */
	private static final String PROPERTY_LOGGING_LEVEL = "LGMSLoggingLevel";
	
	/** System Property: Service Logging Level of Detail */
	private static final String PROPERTY_LOGGING_LEVEL_OF_DETAIL = "LGMSLoggingLevelOfDetail";



	/** Status Message: Success */
	private static final String STATUS_SUCCESS = "OK";
	
	/** Status Message: Failure */
	private static final String STATUS_FAILURE = "FAILURE";
	

	/**
	 * Static Logger Block
	 * Acquires the correct location to the logback.xml configuration file
	 * and triggers the class logger initialization with this location.
	 * Prevents the configuration from loading from another file in the classpath
	 */
	static
	{	
		// Acquire the file location for logback.xml
		ClassLoader classLoader = Loader.getClassLoaderOfObject( new LGMSServiceServer( true ) );
		
		// Determine the file name for the logback.xml configuration file
		String lc = TransportServerImplementation.determineLifeCycle().toString().toLowerCase(Locale.US);
		String configurationFileName = LOGFILE_NAME.replace( LOGFILE_LIFECYCLE, lc );
		
		// Acquire a url to the resource from the class loader
		URL configurationURL = classLoader.getResource(configurationFileName);
		
		// Initialize the logger
		if( configurationURL != null ) {
			// Construct the version for the logging property
			StringBuilder version = new StringBuilder();
			version.append( VERSION_MAJOR );
			version.append( '.' );
			version.append( VERSION_MINOR );
			
			System.setProperty(PROPERTY_SERVICE_VERSION, version.toString() );
			LogInitializer.getInstance().initializeLogger(
				LGMSServiceServer.class,
				configurationURL,
				configurationFileName.toString()
			);
		}
		
		// Initialize the Trust Store for SSL
		TrustStoreManager.initializeTrustStore();
	}
	
	/**
	 * Private Constructor
	 * @param initialized Whether logger is properly initialized
	 */
	private LGMSServiceServer( final Boolean initialized )
	{
		setServiceLogInitialized( initialized );
	}
	
	
	/**
	 * Default Constructor
	 */
	public LGMSServiceServer( )
	{
		// Transport Server Implementation Constructor
		super();
		
		// Note if the service log was not properly initialized before this constructor
		// This could lead to the wrong log file being utilized by the service
		if(!serviceLogInitialized) {
			SERVICELOG.error("Service Log was not properly initialized before constructor was executed.");
		}
	}
	
	/**
	 * Set Service Log Initialized
	 * @param initialized Whether the service log is properly initialized
	 */
	private static void setServiceLogInitialized( final Boolean initialized ) {
		// Set the service log as being initialized
		serviceLogInitialized = initialized;
	}

	
	/**
	 * Get Core SBS Stats
	 * @param request HTTP Request
	 * @return SBSCoreStatusData
	 */
	@GET
	@Path(METHOD_GETCORESBSSTATS)
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<ServiceStatusData> getCoreSBSStats(
			@Form final ServiceRequest request ) 
	{
		// Get Core SBS Stats
		// Authentication: None
		// Authorization:  None
		ServiceResponse<ServiceStatusData> response = this.<ServiceStatusData>validateCommonAPIRequest(
			request,
			false,
			new String[] {}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			ServiceStatusData data = new ServiceStatusData(
				lifeCycle,
				dataSourceType,
				loggingLevelOfDetail,
				this.getClass().getProtectionDomain().getCodeSource().getLocation().toString()
			);
			
			response.setPayload( data );
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * <b>Health Check</b><br>
	 * Performs a shallow health check of the service<br>
	 * which verifies the service is responsive<br>
	 * @param request HTTP Request
	 * @return Service Name
	 */
	@GET
	@Path(METHOD_HEALTHCHECK)
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<String> healthCheck(
			@Form final ServiceRequest request ) 
	{
		// Health Check
		// Authentication: None
		// Authorization:  None
		ServiceResponse<String> response = this.<String>validateCommonAPIRequest(
			request,
			false,
			new String[] {}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			response.setPayload( SERVICE_CATEGORY );
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * <b>Health Check (Shallow)</b><br>
	 * Performs a shallow health check of the service<br>
	 * which verifies the service is responsive<br>
	 * along with a direct service dependencies<br>
	 * @param request HTTP Request
	 * @return Service Name
	 */
	@GET
	@Path(METHOD_HEALTHCHECKSHALLOW)
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<List<ServiceHealthCheck>> healthCheckShallow(
			@Form final ServiceRequest request ) 
	{
		// Health Check
		// Authentication: None
		// Authorization:  None
		ServiceResponse<List<ServiceHealthCheck>> response = this.<List<ServiceHealthCheck>>validateCommonAPIRequest(
			request,
			false,
			new String[] {}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			// Prepare the payload response
			List<ServiceHealthCheck> healthChecks = new ArrayList<ServiceHealthCheck>();
			healthChecks.add( new ServiceHealthCheck(SERVICE_CATEGORY,STATUS_SUCCESS) );
		
			try {
				// Try to create a service authentication object for the client
				Class<?> authenticationClass = Class.forName(CLASSNAME_CLIENT_AUTHENTICATION);
				Constructor<?> authenticationConstructor = authenticationClass.getConstructor( String.class, String.class );
				Object authInfo = authenticationConstructor.newInstance(
						request.getApplicationId(),
						request.getApplicationPasswd() );
			
				// Acquire a list of client classes for service dependencies
				List<String> classNames = ServiceClientLocator.locateServiceClients();
				for( String className : classNames ) {
					try {
						// Try to create a transport client for the service
						Class<?> clientClass = Class.forName( className );
						Constructor<?> clientConstructor = clientClass.getConstructor( authenticationClass );
						Object client = clientConstructor.newInstance( authInfo );
						
						// Try to call a healthCheck() on the service
						Method healthCheckMethod = clientClass.getMethod( METHOD_HEALTHCHECK );
						String result = (String) healthCheckMethod.invoke( client );
						
						// Append the result to this service's results
						healthChecks.add( new ServiceHealthCheck(result,STATUS_SUCCESS) );
					} catch ( Exception e ) {
						// Append the error to this service's results
						SERVICELOG.error( e.getMessage(), e );
						healthChecks.add( new ServiceHealthCheck(className,STATUS_FAILURE) );
						healthChecks.get(0).setStatus( STATUS_FAILURE );
					}
				}
			} catch ( Exception e ) {
				SERVICELOG.debug( EXCEPTION_NOCLIENTS, e );
			}
			
			// Set the payload of the response
			response.setPayload( healthChecks );
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * Resource Check
	 * @param request HTTP Request
	 * @return Service Name
	 */
	@GET
	@Path(METHOD_RESOURCECHECK)
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<ServiceResourceData> resourceCheck(
			@Form final ServiceRequest request ) 
	{
		// Resource Check
		// Authentication: None
		// Authorization:  None
		ServiceResponse<ServiceResourceData> response = this.<ServiceResourceData>validateCommonAPIRequest(
			request,
			false,
			new String[] {}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			response.setPayload( new ServiceResourceData( ) );
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * Performance Check
	 * @param request HTTP Request
	 * @param method Filter to requests against a particular Service Method
	 * @param period Filter to requests around a particular Time(ms)
	 * @return Service Name
	 */
	@GET
	@Path(METHOD_PERFORMANCECHECK)
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<ServicePerformanceSummary> performanceCheck(
			@Form final ServiceRequest request,
			@QueryParam("method") final String method,
			@QueryParam("period") final Integer period ) 
	{
		// Performance Check
		// Authentication: None
		// Authorization:  None
		ServiceResponse<ServicePerformanceSummary> response = this.<ServicePerformanceSummary>validateCommonAPIRequest(
			request,
			false,
			new String[] {}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			// Validate the provided value for periods
			if( period != null && ( period != 1 && period != 5 && period != 15 && period != 30 && period != 60 ) ) {
				response.setStatusCode( ServiceStandardErrorCodes.SC_400.getCode() );
				response.setStatusDescription( EXCEPTION_PERIOD );
			} else {
				// Return data based on the provided criteria (null values allowed)
				response.setPayload( performanceTracker.acquirePerformanceSummary( period, SERVICE_CATEGORY, method ) );
			}
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * Set Logging Level
	 * Assigns a value for the log level to the service
	 * @param request HTTP Request
	 * @param level {TRACE, DEBUG, INFO, WARN, ERROR}
	 * @return Log Level
	 */
	@GET
	@Path("setLoggingLevel/{level}")
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<String> setLoggingLevel(
			@Form final ServiceRequest request,
			@PathParam("level") final String level ) 
	{
		// Set Logging Level
		// Authentication: LDAP
		// Authorization: Administrator
		ServiceResponse<String> response = this.<String>validateCommonAPIRequest(
			request,
			true,
			new String[] {ACG_ADMIN}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			// Set the new log level
			String result = setLoggingLevel(level);
			System.setProperty(PROPERTY_LOGGING_LEVEL, level);
		
			// Report the change in logging level of detail
			SERVICELOG.info("Logging Level: " + getLoggingLevel().toString()); 
			response.setPayload( "Logging Level: " + result );
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * Set Logging Level Of Detail
	 * Assigns a value for the log level to the service
	 * @param request HTTP Request
	 * @param level {OFF, AUDIT, BASIC, FULL}
	 * @return Log Level
	 */
	@GET
	@Path("setLoggingLevelOfDetail/{level}")
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<String> setLoggingLevelOfDetail(
			@Form final ServiceRequest request,
			@PathParam("level") final String level ) 
	{		
		// Set Logging Level of Detail
		// Authentication: LDAP
		// Authorization:  Administrator
		ServiceResponse<String> response = this.<String>validateCommonAPIRequest(
			request,
			true,
			new String[] {ACG_ADMIN}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			// Set the new log level
			String result = setLoggingLevelOfDetail(level);
			System.setProperty(PROPERTY_LOGGING_LEVEL_OF_DETAIL, level);
		
			// Report the change in logging level of detail
			SERVICELOG.info("Logging Level Of Detail: " + getLoggingLevelOfDetail().toString());
			response.setPayload( "Logging Level Of Detail: " + result );
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * Get Service API
	 * @param request HTTP Request
	 * @return Service API
	 */
	@GET
	@Path(METHOD_GETSERVICEAPI)
	@Produces(MIME_APPLICATION_JSON)
	public final ServiceResponse<ServiceAPI> getServiceAPI(
			@Form final ServiceRequest request ) 
	{		
		// Get Service API
		// Authentication: None
		// Authorization:  None
		ServiceResponse<ServiceAPI> response = this.<ServiceAPI>validateCommonAPIRequest(
			request,
			false,
			new String[] {}
		);
		
		// Only set payload if successfully validated
		if ( response.getStatusCode() == ServiceStandardErrorCodes.SC_200.getCode() ) {
			// Establish a complete set of Service APIs
			ServiceAPI serviceCategoryAPI = new ServiceAPI();
			ServiceAPI serviceInterfaceAPI = null;
			
			// Set the service category
			serviceCategoryAPI.setServiceCategory( SERVICE_CATEGORY );
		
			// Set the service version
			String version = VERSION_MAJOR + '.' + VERSION_MINOR + '.' + VERSION_INCREMENTAL;
			serviceCategoryAPI.setServiceVersion( version );

			// Acquire the Service Interface API for LGMS
			serviceInterfaceAPI = getServiceInterfaceAPI( "LGMS" );
			if( serviceInterfaceAPI != null ) {
				// Append the list of methods to the Service Category API
				serviceCategoryAPI.addServiceMethods( serviceInterfaceAPI.getServiceMethods() );
			}

			// Set the payload of the response
			response.setPayload( serviceCategoryAPI );
		}
		
		// Return the response
		return response;
	}
	
	/**
	 * Get Service Interface API
	 * @param interfaceName Service Interface
	 * @return Service API
	 */
	private final ServiceAPI getServiceInterfaceAPI( final String interfaceName )
	{
		// Attempt to read the JSON from the file
		ClassLoader classLoader = Loader.getClassLoaderOfObject( this );
		
		// Setup the version number
		String version = VERSION_MAJOR + '.' + VERSION_MINOR + '.' + VERSION_INCREMENTAL;
		
		// Read the Service Interface API (JSON)
		InputStream fis = null;
		try {
			fis = classLoader.getResource( interfaceName + "API.txt" ).openStream();
			String apiJSON = IOUtils.toString(fis, "UTF-8");
			
			// Update the version number
			apiJSON = apiJSON.replace( "{VERSION}", version );
	
			// Reconstruct the Service API from JSON
			return ServiceAPI.valueOf( apiJSON );
		} catch ( IOException ioe ) {			
			// Log the error and continue
			SERVICELOG.error( "IO Exception: " + interfaceName + ".txt", ioe );
			return null;
		} finally {
			// Close the resource
			if( fis != null ) {
				try {
					fis.close();
				} catch ( IOException e ) {
					// Do Nothing
				}
			}
		}
	}
	
}
