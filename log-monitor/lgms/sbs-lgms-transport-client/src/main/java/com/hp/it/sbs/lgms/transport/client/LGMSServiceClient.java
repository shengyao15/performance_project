package com.hp.it.sbs.lgms.transport.client;

import com.hp.it.sbs.core.client.CompositeImplementation;
import com.hp.it.sbs.core.client.TransportClientImplementation;
import com.hp.it.sbs.core.client.beans.ServiceAPI;
import com.hp.it.sbs.core.client.beans.ServiceAuthentication;
import com.hp.it.sbs.core.client.enums.ExecutionType;
import com.hp.it.sbs.core.client.enums.ImplementationType;
import com.hp.it.sbs.core.client.interfaces.SharedBusinessService;
import com.hp.it.sbs.core.client.logging.ClientActivity;
import com.hp.it.sbs.core.client.logging.ClientActivityTracker;
import com.hp.it.sbs.core.shared.exceptions.CoreServiceException;
import com.hp.it.sbs.core.shared.exceptions.ServiceStandardErrorCodes;
import com.hp.it.sbs.lgms.interfaces.LGMS;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import java.util.ArrayList;

import org.apache.http.auth.Credentials;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * LGMSService Client
 * Service Category:      LGMS
 * Generated By:          sbs-generator
 * Service Version:       1.0.0-SNAPSHOT
 * Core Version:          1.1.2
 * I-Processor Version:   2.1.5
 *
 * This class is generated based upon the service's interface(s).
 * The versions listed above were utilized in the process.
 * These may be snapshots instead of actual releases during development.
 */
public final class LGMSServiceClient extends CompositeImplementation implements LGMSService
{
	/** Logger for Client */
	private static final Logger SERVICELOG = LoggerFactory.getLogger( LGMSServiceClient.class );

	/** Service Category */
	public static final String SERVICE_CATEGORY = "LGMS";
	
	/** Service Version: Major */
	public static final String VERSION_MAJOR = "1";
	
	/** Service Version: Minor */
	public static final String VERSION_MINOR = "0";
	
	/** Service Version: Incremental */
	public static final String VERSION_INCREMENTAL = "0";
	
	
	
	/** Error: Factory failed to instantiate interface */
	public static final String INTERFACE_UNAVAILABLE = 
			"Factory failed to provide an implementation for interface {} from service category LGMS. ";
		
	/** Error: Factory failed to instantiate interface */
	public static final String METHODS_UNAVAILABLE =  "The following method(s) will be unavailable: {}";
	
	/** Error: Factory failed to instantiate interface */
	public static final String SERVICE_FACTORY_ERROR = INTERFACE_UNAVAILABLE + METHODS_UNAVAILABLE;
	
	/** Error: Failed to update timeout on transport client */
	public static final String SERVICE_TIMEOUT_ERROR = "Unable to update timeout (ms) on service client: ";
	
	/** Error: Failed to update credentials on transport client */
	public static final String SERVICE_CREDENTIALS_ERROR = "Unable to update credentials on service client: ";
	
	
	/** Type Literal: Integer */
	private static final String TYPE_INTEGER = "Integer";
	/** Type Literal: ServiceAPI */
	private static final String TYPE_SERVICEAPI = "ServiceAPI";
	/** Type Literal: String */
	private static final String TYPE_STRING = "String";

	/** Method Literal: getLGMSValue */
	private static final String METHOD_GETLGMSVALUE = "getLGMSValue";
	/** Method Literal: getServiceAPI */
	private static final String METHOD_GETSERVICEAPI = "getServiceAPI";
	/** Method Literal: healthCheck */
	private static final String METHOD_HEALTHCHECK = "healthCheck";
	/** Method Literal: resetLGMSValue */
	private static final String METHOD_RESETLGMSVALUE = "resetLGMSValue";
	/** Method Literal: setLGMSValue */
	private static final String METHOD_SETLGMSVALUE = "setLGMSValue";
	/** Method Literal: testParseFile */
	private static final String METHOD_TESTPARSEFILE = "testParseFile";

	
	// Instance of SharedBusinessService for executing methods
	private SharedBusinessService clientCommonAPI = null;

	// Instance of LGMS for executing methods
	private LGMS clientLGMS = null;

	/**
	 * Constructor with Authentication Information
	 * @param authentication Service Authentication Information
	 */
	public LGMSServiceClient( final ServiceAuthentication authentication )
	{
		// Create the necessary service clients
		instantiateServiceClients( authentication, ImplementationType.REAL, ExecutionType.REMOTE );
	}
	
	/**
	 * Parameterized Constructor with Authentication Information
	 * @param authentication Service Authentication Information
	 * @param implementation Type of Service Implementation (Real or Mock or Stub)
	 * @param execution Type of Service Execution (Local or Remote)
	 */
	public LGMSServiceClient(
			final ServiceAuthentication authentication,
			final ImplementationType implementation,
			final ExecutionType execution )
	{
		// Create the necessary service clients
		instantiateServiceClients( authentication, implementation, execution );
	}
		
	/**
	 * Instantiate Service Clients
	 * @param authentication Service Authentication Information
	 * @param implementation Type of Service Implementation (Real or Mock or Stub)
	 * @param execution Type of Service Execution (Local or Remote)
	 */
	private void instantiateServiceClients(
			final ServiceAuthentication authentication,
			final ImplementationType implementation,
			final ExecutionType execution )
	{
		SERVICELOG.debug( "Instantiating LGMSServiceClient" );
		
		// Store the Application Id
		applicationId = authentication.getApplicationId( );
		
		try {
			// Acquire an instance of SharedBusinessService
			SERVICELOG.debug( "Acquiring instance of SharedBusinessService" );
			clientCommonAPI = LGMSCommonFactory.getInstance( authentication, implementation, execution );
		} catch ( CoreServiceException cse ) {
			// Note the missing functionality but continue
			SERVICELOG.error(
				SERVICE_FACTORY_ERROR,
				LGMSCommonFactory.SERVICE_INTERFACE,
				LGMSCommonFactory.SERVICE_METHODS
			);
		}

		try {
			// Acquire an instance of LGMS through its factory
			SERVICELOG.debug( "Acquiring instance of LGMS" );
			clientLGMS = LGMSFactory.getInstance( authentication, implementation, execution );
		} catch ( CoreServiceException cse ) {
			// Note the missing functionality but continue
			SERVICELOG.error(
				SERVICE_FACTORY_ERROR,
				LGMSFactory.SERVICE_INTERFACE,
				LGMSFactory.SERVICE_METHODS
			);
		}
	}
	
	/**
	 * Get Service Class Version Number
	 * @return Version
	 */
	public static String getServiceVersion( ) {
		return VERSION_MAJOR + '.' + VERSION_MINOR + '.' + VERSION_INCREMENTAL;
	}
	
	/**
	 * Get Service Version Number
	 * @return Version
	 */
	public String getVersion( ) {
		return getServiceVersion( );
	}
	
	/**
	 * Get Service Major Version Number
	 * @return Major Version
	 */
	public String getMajorVersion( ) {
		return VERSION_MAJOR;
	}
	
	/**
	 * Get Service Minor Version Number
	 * @return Minor Version
	 */
	public String getMinorVersion( ) {
		return VERSION_MINOR;
	}
	
	/**
	 * Get Service Incremental Version Number
	 * @return IncrementalVersion
	 */
	public String getIncrementalVersion( ) {
		return VERSION_INCREMENTAL;
	}
	
	/**
	 * Get Service URL
	 * @return URL
	 */
	public String getServiceURL( ) {
		// Generate the Service URL
		String url = null;
//		String url = generateURL(
//					determineLifeCycle(),
//					SERVICE_CATEGORY,
//					null,
//					VERSION_MAJOR,
//					VERSION_MINOR,
//					VERSION_INCREMENTAL );
	
		// Return the Service URL
		return url;
	}
	
	/**
	 * Set the Client's Authentication Information
	 * @param authentication Authentication Information
	 */
	public void setAuthentication( final ServiceAuthentication authentication )
	{
		// Store the Application Id
		applicationId = authentication.getApplicationId( );

		// Set the client authentication on the transport client
		if( clientLGMS instanceof TransportClientImplementation ) {
			((TransportClientImplementation) clientLGMS).setCachedAuthentication( authentication );
		}

	}
	
	/**
	 * Set the Client's Application Id
	 * @param id Application Id
	 */
	public void setApplicationId( final String id )
	{
		// Store the Application Id
		applicationId = id;
		

		// Set the application id on the transport client
		if( clientLGMS instanceof TransportClientImplementation ) {
			((TransportClientImplementation) clientLGMS).setApplicationId( id );
		}

	}
	
	/**
	 * Set the Client's Application Password
	 * @param password Application Password
	 */
	public void setApplicationPassword( final String password )
	{

		// Set the application password on the transport client
		if( clientLGMS instanceof TransportClientImplementation ) {
			((TransportClientImplementation) clientLGMS).setApplicationPassword( password );
		}

	}
	
	/**
	 * Set the Client's Unit Of Work Id
	 * @param id Unit Of Work Id
	 */
	public void setUnitOfWorkId( final String id )
	{
		// Store the new value
		unitOfWorkId = id;
		

		// Set the unit of work id on the transport client
		if( clientLGMS instanceof TransportClientImplementation ) {
			((TransportClientImplementation) clientLGMS).setUnitOfWorkId( id );
		}

	}
	
	/**
	 * <b>Set Client Credentials on Service Interface</b><br/>
	 * Sets the authentication credentials for connecting to the server<br/>
	 * These determine with scheme may be utilized to answer an authentication challenge<br/>
	 * Currently Basic and NTLM are supported by the service clients<br/>
	 * @param clazz Service Interface for the credentials
	 * @param credentials Authentication Credentials
	 */
	public void setCredentialsOnServiceInterface(
		final Class<?> clazz,
		final Credentials credentials )
	{
		try {		

			// If possible, set the credentials on the transport client
			if( clientLGMS instanceof TransportClientImplementation
				&& clazz.isAssignableFrom( clientLGMS.getClass() ) )
			{
				// Invoke the method on the transport client
				Method m = clientLGMS.getClass().getMethod( "setCredentials", Credentials.class );
				m.invoke( clientLGMS, credentials );
			}
	
		} catch ( SecurityException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_CREDENTIALS_ERROR + clazz.getSimpleName(), e );
		} catch ( NoSuchMethodException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_CREDENTIALS_ERROR + clazz.getSimpleName(), e );
		} catch ( IllegalArgumentException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_CREDENTIALS_ERROR + clazz.getSimpleName(), e );
		} catch ( IllegalAccessException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_CREDENTIALS_ERROR + clazz.getSimpleName(), e );
		} catch ( InvocationTargetException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_CREDENTIALS_ERROR + clazz.getSimpleName(), e );
		}
	}	
	/**
	 * <b>Set Connection Timeout on Service Interface</b><br/>
	 * Sets the amount of time (ms) spent establishing a connection to the server<br/>
	 * If the period of time is exhausted, an exception will be thrown and connection attempt halted<br/>
	 * @param clazz Service Interface for the timeout
	 * @param duration Period of Time (ms)
	 */
	public void setConnectionTimeoutOnServiceInterface(
		final Class<?> clazz,
		final Integer duration )
	{
		try {		

			// If possible, set the connection timeout on the transport client
			if( clientLGMS instanceof TransportClientImplementation
				&& clazz.isAssignableFrom( clientLGMS.getClass() ) )
			{
				// Invoke the method on the transport client
				Method m = clientLGMS.getClass().getMethod( "setConnectionTimeout", Integer.class );
				m.invoke( clientLGMS, duration );
			}
	
		} catch ( SecurityException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( NoSuchMethodException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( IllegalArgumentException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( IllegalAccessException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( InvocationTargetException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		}
	}	
	/**
	 * <b>Set Socket Timeout on Service Interface</b><br/>
	 * Sets the amount of time (ms) spent reading from a connection to the server<br/>
	 * If the period of time is exhausted, an exception will be thrown and the service request will be abandoned<br/>
	 * @param clazz Service Interface for the timeout
	 * @param duration Period of Time (ms)
	 */
	public void setSocketTimeoutOnServiceInterface(
		final Class<?> clazz,
		final Integer duration )
	{
		try {		

			// If possible, set the socket timeout on the transport client
			if( clientLGMS instanceof TransportClientImplementation
				&& clazz.isAssignableFrom( clientLGMS.getClass() ) )
			{
				// Invoke the method on the transport client
				Method m = clientLGMS.getClass().getMethod( "setSocketTimeout", Integer.class );
				m.invoke( clientLGMS, duration );
			}
	
		} catch ( SecurityException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( NoSuchMethodException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( IllegalArgumentException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( IllegalAccessException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		} catch ( InvocationTargetException e ) {
			// Log the error and continue
			SERVICELOG.error( SERVICE_TIMEOUT_ERROR + clazz.getSimpleName(), e );
		}
	}	
	/**
	 * Set Whether Performing a Test Request
	 * @param flag Test Request
	 */
	public void setTestFlag( final Boolean flag )
	{

		// Set the flag for the execution type
		if( clientLGMS instanceof TransportClientImplementation ) {
			((TransportClientImplementation) clientLGMS).setTestFlag( flag );
		}

	}
	
	/**
	 * Set Whether Performing a Mock Request
	 * @param flag Mock Request
	 */
	public void setMockFlag( final Boolean flag )
	{

		// Set the flag for the execution type
		if( clientLGMS instanceof TransportClientImplementation ) {
			((TransportClientImplementation) clientLGMS).setMockFlag( flag );
		}

	}
	
	/**
	 * Set Whether Performing a Stub Request
	 * @param flag Stub Request
	 */
	public void setStubFlag( final Boolean flag )
	{

		// Set the flag for the execution type
		if( clientLGMS instanceof TransportClientImplementation ) {
			((TransportClientImplementation) clientLGMS).setStubFlag( flag );
		}

	}
	
	/**
	 * Health Check
	 * @return Status
	 */
	public String healthCheck()
	{
		// Check if the SharedBusinessService was properly instantiated
		if( clientCommonAPI == null ) {
			SERVICELOG.error( "The method SharedBusinessService.healthCheck() from service category LGMS is unavailable" );
			return null;
		}
	
		// Start tracking the time required to send request to configureDevice()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);
		
		// Check if the Unit of Work Id is valid
		if ( this.unitOfWorkId == null || this.unitOfWorkId.trim().length() == 0 ) {
			// Generate a new one if necessary
			this.unitOfWorkId = generateUnitOfWorkId();
			setUnitOfWorkId( this.unitOfWorkId );
		}
		
		// Store any exception thrown
		CoreServiceException sbsMethodException = null;
		
		// Setup the return object
		String sbsMethodResult = null;
		
		// Setup the status code
		String sbsMethodStatus = null;

		try {
			// Call the method with the appropriate transport client
			sbsMethodResult = clientCommonAPI.healthCheck( );
			
			// Set a successful status code since no exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_200.getCode() );
		} catch ( CoreServiceException sbsCoreServiceException ) {
			// Capture the exception to be thrown after logging & processing
			sbsMethodException = sbsCoreServiceException;
			
			// Set a unsuccessful status code since an exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_500.getCode() );
		}

		// Stop tracking the activity
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);

		// Provide a list of parameter types
		ArrayList<String> sbsMethodParameterTypes = new ArrayList<String>();

		// Generate the log output
		generateTransportLog(
				SERVICE_CATEGORY,
				METHOD_HEALTHCHECK,
				sbsMethodStatus,
				TYPE_STRING,
				sbsMethodResult,
				sbsMethodParameterTypes
		);
		
		// Clear the last Unit of Work Id
		setUnitOfWorkId( null );
		
		// Cleanup thread locals
		ClientActivityTracker.clearThreadLocalVariables();

		// Check if an exception should now be thrown
		if( sbsMethodException != null ) {
			throw sbsMethodException;
		}
		
		// Return the response to healthCheck()
		return sbsMethodResult;
	}

	/**
	 * Get Service API
	 * @return ServiceAPI
	 */
	public ServiceAPI getServiceAPI()
	{
		// Check if the SharedBusinessService was properly instantiated
		if( clientCommonAPI == null ) {
			SERVICELOG.error( "The method SharedBusinessService.getServiceAPI() from service category LGMS is unavailable" );
			return null;
		}
	
		// Start tracking the time required to send request to configureDevice()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);
		
		// Check if the Unit of Work Id is valid
		if ( this.unitOfWorkId == null || this.unitOfWorkId.trim().length() == 0 ) {
			// Generate a new one if necessary
			this.unitOfWorkId = generateUnitOfWorkId();
			setUnitOfWorkId( this.unitOfWorkId );
		}
		
		// Store any exception thrown
		CoreServiceException sbsMethodException = null;
		
		// Setup the return object
		ServiceAPI sbsMethodResult = null;
		
		// Setup the status code
		String sbsMethodStatus = null;

		try {
			// Call the method with the appropriate transport client
			sbsMethodResult = clientCommonAPI.getServiceAPI( );
			
			// Set a successful status code since no exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_200.getCode() );
		} catch ( CoreServiceException sbsCoreServiceException ) {
			// Capture the exception to be thrown after logging & processing
			sbsMethodException = sbsCoreServiceException;
			
			// Set a unsuccessful status code since an exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_500.getCode() );
		}

		// Stop tracking the activity
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);

		// Provide a list of parameter types
		ArrayList<String> sbsMethodParameterTypes = new ArrayList<String>();

		// Generate the log output
		generateTransportLog(
				SERVICE_CATEGORY,
				METHOD_GETSERVICEAPI,
				sbsMethodStatus,
				TYPE_SERVICEAPI,
				sbsMethodResult,
				sbsMethodParameterTypes
		);
		
		// Clear the last Unit of Work Id
		setUnitOfWorkId( null );
		
		// Cleanup thread locals
		ClientActivityTracker.clearThreadLocalVariables();

		// Check if an exception should now be thrown
		if( sbsMethodException != null ) {
			throw sbsMethodException;
		}
		
		// Return the response to getServiceAPI()
		return sbsMethodResult;
	}

	/**
	 * {@inheritDoc}
	 * @see com.hp.it.sbs.lgms.interfaces.LGMS#getLGMSValue LGMS
	 */
	public String getLGMSValue(  )
	{
		// Check if the LGMS was properly instantiated
		if( clientLGMS == null ) {
			SERVICELOG.error( "The method LGMS.getLGMSValue() from service category LGMS is unavailable" );
			return null;
		}
	
		// Start tracking the time required to send request to getLGMSValue()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);
		
		// Check if the Unit of Work Id is valid
		if ( this.unitOfWorkId == null || this.unitOfWorkId.trim().length() == 0 ) {
			// Generate a new one if necessary
			this.unitOfWorkId = generateUnitOfWorkId();
			setUnitOfWorkId( this.unitOfWorkId );
		}
		
		// Store any exception thrown
		CoreServiceException sbsMethodException = null;
		
		// Setup the return object
		String sbsMethodResult = null;
		
		// Setup the status code
		String sbsMethodStatus = null;
		
		

		try {
			// Call the method with the appropriate transport client
			sbsMethodResult = clientLGMS.getLGMSValue();
			
			// Set a successful status code since no exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_200.getCode() );
		} catch ( CoreServiceException sbsCoreServiceException ) {
			// Capture the exception to be thrown after logging & processing
			sbsMethodException = sbsCoreServiceException;
			
			// Set a unsuccessful status code since an exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_500.getCode() );
		}

		// Stop tracking the activity
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);

		// Provide a list of parameter types
		ArrayList<String> sbsMethodParameterTypes = new ArrayList<String>();

		// Generate the log output
		generateTransportLog(
				SERVICE_CATEGORY,
				METHOD_GETLGMSVALUE,
				sbsMethodStatus,
				TYPE_STRING,
				sbsMethodResult,
				sbsMethodParameterTypes
		);
		
		// Clear the last Unit of Work Id
		setUnitOfWorkId( null );
		
		// Cleanup thread locals
		ClientActivityTracker.clearThreadLocalVariables();

		// Check if an exception should now be thrown
		if( sbsMethodException != null ) {
			throw sbsMethodException;
		}
		
		// Return the response to getLGMSValue()
		return sbsMethodResult;
	}
	
	/**
	 * {@inheritDoc}
	 * @see com.hp.it.sbs.lgms.interfaces.LGMS#setLGMSValue LGMS
	 */
	public Integer setLGMSValue( 
			final String lgmsValue )
	{
		// Check if the LGMS was properly instantiated
		if( clientLGMS == null ) {
			SERVICELOG.error( "The method LGMS.setLGMSValue() from service category LGMS is unavailable" );
			return null;
		}
	
		// Start tracking the time required to send request to setLGMSValue()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);
		
		// Check if the Unit of Work Id is valid
		if ( this.unitOfWorkId == null || this.unitOfWorkId.trim().length() == 0 ) {
			// Generate a new one if necessary
			this.unitOfWorkId = generateUnitOfWorkId();
			setUnitOfWorkId( this.unitOfWorkId );
		}
		
		// Store any exception thrown
		CoreServiceException sbsMethodException = null;
		
		// Setup the return object
		Integer sbsMethodResult = null;
		
		// Setup the status code
		String sbsMethodStatus = null;
		
		

		try {
			// Call the method with the appropriate transport client
			sbsMethodResult = clientLGMS.setLGMSValue(
				lgmsValue);
			
			// Set a successful status code since no exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_200.getCode() );
		} catch ( CoreServiceException sbsCoreServiceException ) {
			// Capture the exception to be thrown after logging & processing
			sbsMethodException = sbsCoreServiceException;
			
			// Set a unsuccessful status code since an exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_500.getCode() );
		}

		// Stop tracking the activity
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);

		// Provide a list of parameter types
		ArrayList<String> sbsMethodParameterTypes = new ArrayList<String>();
		sbsMethodParameterTypes.add(TYPE_STRING);

		// Generate the log output
		generateTransportLog(
				SERVICE_CATEGORY,
				METHOD_SETLGMSVALUE,
				sbsMethodStatus,
				TYPE_INTEGER,
				sbsMethodResult,
				sbsMethodParameterTypes,
				lgmsValue
		);
		
		// Clear the last Unit of Work Id
		setUnitOfWorkId( null );
		
		// Cleanup thread locals
		ClientActivityTracker.clearThreadLocalVariables();

		// Check if an exception should now be thrown
		if( sbsMethodException != null ) {
			throw sbsMethodException;
		}
		
		// Return the response to setLGMSValue()
		return sbsMethodResult;
	}
	
	/**
	 * {@inheritDoc}
	 * @see com.hp.it.sbs.lgms.interfaces.LGMS#resetLGMSValue LGMS
	 */
	public Integer resetLGMSValue( 
			final String lgmsValue )
	{
		// Check if the LGMS was properly instantiated
		if( clientLGMS == null ) {
			SERVICELOG.error( "The method LGMS.resetLGMSValue() from service category LGMS is unavailable" );
			return null;
		}
	
		// Start tracking the time required to send request to resetLGMSValue()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);
		
		// Check if the Unit of Work Id is valid
		if ( this.unitOfWorkId == null || this.unitOfWorkId.trim().length() == 0 ) {
			// Generate a new one if necessary
			this.unitOfWorkId = generateUnitOfWorkId();
			setUnitOfWorkId( this.unitOfWorkId );
		}
		
		// Store any exception thrown
		CoreServiceException sbsMethodException = null;
		
		// Setup the return object
		Integer sbsMethodResult = null;
		
		// Setup the status code
		String sbsMethodStatus = null;
		
		

		try {
			// Call the method with the appropriate transport client
			sbsMethodResult = clientLGMS.resetLGMSValue(
				lgmsValue);
			
			// Set a successful status code since no exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_200.getCode() );
		} catch ( CoreServiceException sbsCoreServiceException ) {
			// Capture the exception to be thrown after logging & processing
			sbsMethodException = sbsCoreServiceException;
			
			// Set a unsuccessful status code since an exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_500.getCode() );
		}

		// Stop tracking the activity
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);

		// Provide a list of parameter types
		ArrayList<String> sbsMethodParameterTypes = new ArrayList<String>();
		sbsMethodParameterTypes.add(TYPE_STRING);

		// Generate the log output
		generateTransportLog(
				SERVICE_CATEGORY,
				METHOD_RESETLGMSVALUE,
				sbsMethodStatus,
				TYPE_INTEGER,
				sbsMethodResult,
				sbsMethodParameterTypes,
				lgmsValue
		);
		
		// Clear the last Unit of Work Id
		setUnitOfWorkId( null );
		
		// Cleanup thread locals
		ClientActivityTracker.clearThreadLocalVariables();

		// Check if an exception should now be thrown
		if( sbsMethodException != null ) {
			throw sbsMethodException;
		}
		
		// Return the response to resetLGMSValue()
		return sbsMethodResult;
	}
	
	/**
	 * {@inheritDoc}
	 * @see com.hp.it.sbs.lgms.interfaces.LGMS#testParseFile LGMS
	 */
	public String testParseFile( 
			final String fileName )
	{
		// Check if the LGMS was properly instantiated
		if( clientLGMS == null ) {
			SERVICELOG.error( "The method LGMS.testParseFile() from service category LGMS is unavailable" );
			return null;
		}
	
		// Start tracking the time required to send request to testParseFile()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);
		
		// Check if the Unit of Work Id is valid
		if ( this.unitOfWorkId == null || this.unitOfWorkId.trim().length() == 0 ) {
			// Generate a new one if necessary
			this.unitOfWorkId = generateUnitOfWorkId();
			setUnitOfWorkId( this.unitOfWorkId );
		}
		
		// Store any exception thrown
		CoreServiceException sbsMethodException = null;
		
		// Setup the return object
		String sbsMethodResult = null;
		
		// Setup the status code
		String sbsMethodStatus = null;
		
		

		try {
			// Call the method with the appropriate transport client
			sbsMethodResult = clientLGMS.testParseFile(
				fileName);
			
			// Set a successful status code since no exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_200.getCode() );
		} catch ( CoreServiceException sbsCoreServiceException ) {
			// Capture the exception to be thrown after logging & processing
			sbsMethodException = sbsCoreServiceException;
			
			// Set a unsuccessful status code since an exception was thrown
			sbsMethodStatus = String.valueOf( ServiceStandardErrorCodes.SC_500.getCode() );
		}

		// Stop tracking the activity
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_EXECUTE_METHOD);

		// Provide a list of parameter types
		ArrayList<String> sbsMethodParameterTypes = new ArrayList<String>();
		sbsMethodParameterTypes.add(TYPE_STRING);

		// Generate the log output
		generateTransportLog(
				SERVICE_CATEGORY,
				METHOD_TESTPARSEFILE,
				sbsMethodStatus,
				TYPE_STRING,
				sbsMethodResult,
				sbsMethodParameterTypes,
				fileName
		);
		
		// Clear the last Unit of Work Id
		setUnitOfWorkId( null );
		
		// Cleanup thread locals
		ClientActivityTracker.clearThreadLocalVariables();

		// Check if an exception should now be thrown
		if( sbsMethodException != null ) {
			throw sbsMethodException;
		}
		
		// Return the response to testParseFile()
		return sbsMethodResult;
	}
	
}
