package com.hp.it.sbs.lgms.transport.client;

import com.hp.it.sbs.core.client.beans.ServiceAuthentication;
import com.hp.it.sbs.core.client.enums.ExecutionType;
import com.hp.it.sbs.core.client.enums.ImplementationType;
import com.hp.it.sbs.core.client.interfaces.SharedBusinessService;
import com.hp.it.sbs.core.shared.exceptions.CoreServiceException;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import java.util.Locale;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * LGMS Common Factory
 * Service Category:      LGMS
 * Generated By:          sbs-generator
 * Service Version:       1.0.0-SNAPSHOT
 * I-Processor Version:   2.1.5
 *
 * This class is generated based upon the service's interface.
 * The versions listed above were utilized in the process.
 * These may be snapshots instead of actual releases.
 */
final class LGMSCommonFactory
{
	/** Service Category */
	public static final String SERVICE_CATEGORY = "LGMS";
	
	/** Service Interface */
	public static final String SERVICE_INTERFACE = "SharedBusinessService";
	
	/** Service Methods */
	public static final String SERVICE_METHODS = "healthCheck, getServiceAPI";

	/** Logger for factory */
	private static final Logger SERVICELOG = LoggerFactory.getLogger( LGMSCommonFactory.class );

	/** Default Class Package of all Shared Business Services */
	private static final String SBS_PACKAGE = "com.hp.it.sbs.";

	/** Common value that is printed in exceptions */
	private static final String SBS_FACTORY_MSG = "A factory for service category LGMS encountered a problem instantiating an implementation for interface SharedBusinessService";

	/** Class Name of Service Transport Client */
	private static final String SERVICE_REAL_CLASSNAME = SBS_PACKAGE + SERVICE_CATEGORY.toLowerCase( Locale.US ) + ".transport.client."
			+ SERVICE_CATEGORY + "CommonTransportClientREST";

	/** Class Name of Service Mock */
	private static final String SERVICE_MOCK_CLASSNAME = SBS_PACKAGE + SERVICE_CATEGORY.toLowerCase( Locale.US ) + ".service.mock."
			+ "Mock" + SERVICE_CATEGORY + "CommonImpl";
			
	/** Class Name of Service Stub */
	private static final String SERVICE_STUB_CLASSNAME = SBS_PACKAGE + SERVICE_CATEGORY.toLowerCase( Locale.US ) + ".service.stub."
			+ SERVICE_CATEGORY + "CommonStub";
	


	/**
	 * Private Constructor for the factory
	 */
	private LGMSCommonFactory()
	{
		// Do nothing
	}

	/**
	 * Get Instance
	 * Returns instance of a client implementation
	 * @param authInfo Service Authentication
	 * @return SharedBusinessService Shared Business Service
	 */
	public static SharedBusinessService getInstance(
			final ServiceAuthentication authInfo
		)
	{
		//Default the values to a remote execution against the real service
		return getInstance( authInfo, ImplementationType.REAL, ExecutionType.REMOTE );
	}

	/**
	 * Get Instance
	 * Returns instance of a client implementation
	 * May either be the client or mock
	 * @param authInfo Service Authentication
	 * @param implementation Implementation Type - STUB, MOCK, or REAL
	 * @param execution Execution Type - LOCAL or REMOTE
	 * @return SharedBusinessService Shared Business Service
	 */
	public static SharedBusinessService getInstance(
			final ServiceAuthentication authInfo,
			final ImplementationType implementation,
			final ExecutionType execution
		)
	{
		/** Service Interface */
		SharedBusinessService result = null;

		/** Instantiate the Service based upon the purpose */
		try {
			result = instantiateClass(
				authInfo,
				implementation,
				execution
			);
		} catch ( ClassNotFoundException cnf ) {
			// The classpath was most likely not setup
			SERVICELOG.error( SBS_FACTORY_MSG + " -- Class Not Found", cnf );
			throw new CoreServiceException( SBS_FACTORY_MSG + " -- Class Not Found", cnf );
		} catch ( NoSuchMethodException nsm ) {
			// The necessary construction methods could not be found
			SERVICELOG.error( SBS_FACTORY_MSG + " -- No Such Method", nsm );
			throw new CoreServiceException( SBS_FACTORY_MSG + " -- No Such Method", nsm );
		} catch ( IllegalArgumentException iare ) {
			// The method signature did not match expectations
			SERVICELOG.error( SBS_FACTORY_MSG + " -- Illegal Argument", iare );
			throw new CoreServiceException( SBS_FACTORY_MSG + " -- Illegal Argument", iare );
		} catch ( InstantiationException ie ) {
			// Unable to instantiate the class
			SERVICELOG.error( SBS_FACTORY_MSG + " -- Instantiation", ie );
			throw new CoreServiceException( SBS_FACTORY_MSG + " -- Instantiation", ie );
		} catch ( IllegalAccessException iae ) {
			// Wrong visibility defined on method or class
			SERVICELOG.error( SBS_FACTORY_MSG + " -- Illegal Access", iae );
			throw new CoreServiceException( SBS_FACTORY_MSG + " -- Illegal Access", iae );
		} catch ( InvocationTargetException ite ) {
			// Wrong visibility defined on method or class
			SERVICELOG.error( SBS_FACTORY_MSG + " -- Invocation Target", ite );
			throw new CoreServiceException( SBS_FACTORY_MSG + " -- Invocation Target", ite );
		}
		
		// Ensure the class was properly instantiated
		if( result == null ) {
			// No implementation could be provided for the given arguments
			SERVICELOG.error( SBS_FACTORY_MSG + " -- Implementation Unavailable or Not Allowed" );
			throw new CoreServiceException( SBS_FACTORY_MSG + " -- Implementation Unavailable or Not Allowed" );
		}

		// Return the SharedBusinessService
		return result;
	}

	/**
	 * Instantiate Class
	 * @param authInfo Service Authentication
	 * @param implementation Implementation Type - STUB, MOCK, or REAL
	 * @param execution Execution Type - LOCAL or REMOTE
	 * @return SharedBusinessService Shared Business Service
	 * @throws ClassNotFoundException The class is not properly setup in the classpath
	 * @throws NoSuchMethodException The class's constructor could not be found through reflection
	 * @throws InstantiationException Error while executing constructor to instantiate the class
	 * @throws IllegalAccessException Error while executing constructor to instantiate the class
	 * @throws InvocationTargetException Error while executing constructor to instantiate the class
	 */
	private static SharedBusinessService instantiateClass(
			final ServiceAuthentication authInfo,
			final ImplementationType implementation,
			final ExecutionType execution )
			throws ClassNotFoundException, NoSuchMethodException, InstantiationException,
					IllegalAccessException, InvocationTargetException
	{
		// Determine based on the Implementation Type
		switch ( implementation ) {
			case STUB:
				return instantiateStubClass( authInfo, execution );
			case MOCK:
				return instantiateMockClass( authInfo, execution );
			case REAL:
				return instantiateRealClass( authInfo, execution );
			default:
				return null;
		}
	}
	
	/**
	 * Instantiate Stub Class
	 * @param authInfo Service Authentication
	 * @param execution Execution Type - LOCAL or REMOTE
	 * @return SharedBusinessService Shared Business Service
	 * @throws ClassNotFoundException The class is not properly setup in the classpath
	 * @throws NoSuchMethodException The class's constructor could not be found through reflection
	 * @throws InstantiationException Error while executing constructor to instantiate the class
	 * @throws IllegalAccessException Error while executing constructor to instantiate the class
	 * @throws InvocationTargetException Error while executing constructor to instantiate the class
	 */
	private static SharedBusinessService instantiateStubClass(
			final ServiceAuthentication authInfo,
			final ExecutionType execution )
			throws ClassNotFoundException, NoSuchMethodException, InstantiationException,
					IllegalAccessException, InvocationTargetException
	{
		/** Service Interface */
		SharedBusinessService result = null;

		/** Service Class (Stub) */
		Class<?> serviceClass;

		/** Service Constructor */
		Constructor<?> constructor = null;
	
		// Determine the stub implementation based on the Execution Type
		switch ( execution ) {
			case LOCAL:
				// Instantiate the stub implementation
				serviceClass = Class.forName( SERVICE_STUB_CLASSNAME );

				// Call constructor here with authentication info.
				constructor = serviceClass.getConstructor( );
				result = (SharedBusinessService) constructor.newInstance( );
				break;
			case REMOTE:
				// Instantiate the client implementation
				serviceClass = Class.forName( SERVICE_REAL_CLASSNAME );
	
				// Call constructor here with authentication info.
				constructor = serviceClass.getConstructor( ServiceAuthentication.class );
				result = (SharedBusinessService) constructor.newInstance( authInfo );
	
				/** Set the stub implementation flag on the transport client */
				Method setStubFlagMethod = serviceClass.getMethod( "setStubFlag", Boolean.class );
				setStubFlagMethod.invoke( result, Boolean.TRUE );
				break;
			default:
				break;
		}
		
		// Return the class
		return result;
	}
	
	/**
	 * Instantiate Mock Class
	 * @param authInfo Service Authentication
	 * @param execution Execution Type - LOCAL or REMOTE
	 * @return SharedBusinessService Shared Business Service
	 * @throws ClassNotFoundException The class is not properly setup in the classpath
	 * @throws NoSuchMethodException The class's constructor could not be found through reflection
	 * @throws InstantiationException Error while executing constructor to instantiate the class
	 * @throws IllegalAccessException Error while executing constructor to instantiate the class
	 * @throws InvocationTargetException Error while executing constructor to instantiate the class
	 */
	private static SharedBusinessService instantiateMockClass(
			final ServiceAuthentication authInfo,
			final ExecutionType execution )
			throws ClassNotFoundException, NoSuchMethodException, InstantiationException,
					IllegalAccessException, InvocationTargetException
	{
		/** Service Interface */
		SharedBusinessService result = null;

		/** Service Class (Mock) */
		Class<?> serviceClass;

		/** Service Constructor */
		Constructor<?> constructor = null;
	
		// Determine the mock implementation based on the Execution Type
		switch ( execution ) {
			case LOCAL:
				// Instantiate the mock implementation
				serviceClass = Class.forName( SERVICE_MOCK_CLASSNAME );

				// Call constructor here with authentication info.
				constructor = serviceClass.getConstructor( );
				result = (SharedBusinessService) constructor.newInstance( );
				break;
			case REMOTE:
				// Instantiate the client implementation
				serviceClass = Class.forName( SERVICE_REAL_CLASSNAME );
	
				// Call constructor here with authentication info.
				constructor = serviceClass.getConstructor( ServiceAuthentication.class );
				result = (SharedBusinessService) constructor.newInstance( authInfo );
	
				/** Set the mock implementation flag on the transport client */
				Method setMockFlagMethod = serviceClass.getMethod( "setMockFlag", Boolean.class );
				setMockFlagMethod.invoke( result, Boolean.TRUE );
				break;
			default:
				break;
		}
		
		// Return the class
		return result;
	}
	
	/**
	 * Instantiate Real Class
	 * @param authInfo Service Authentication
	 * @param execution Execution Type - LOCAL or REMOTE
	 * @return SharedBusinessService Shared Business Service
	 * @throws ClassNotFoundException The class is not properly setup in the classpath
	 * @throws NoSuchMethodException The class's constructor could not be found through reflection
	 * @throws InstantiationException Error while executing constructor to instantiate the class
	 * @throws IllegalAccessException Error while executing constructor to instantiate the class
	 * @throws InvocationTargetException Error while executing constructor to instantiate the class
	 */
	private static SharedBusinessService instantiateRealClass(
			final ServiceAuthentication authInfo,
			final ExecutionType execution )
			throws ClassNotFoundException, NoSuchMethodException, InstantiationException,
					IllegalAccessException, InvocationTargetException
	{
		/** Service Interface */
		SharedBusinessService result = null;

		/** Service Class (Real) */
		Class<?> serviceClass;

		/** Service Constructor */
		Constructor<?> constructor = null;
	
		// Determine the real implementation based on the Execution Type
		switch ( execution ) {
			case LOCAL:
				// Impossible or not allowed
				break;
			case REMOTE:
				// Instantiate the client implementation
				serviceClass = Class.forName( SERVICE_REAL_CLASSNAME );

				// Call constructor here with authentication info.
				constructor = serviceClass.getConstructor( ServiceAuthentication.class );
				result = (SharedBusinessService) constructor.newInstance( authInfo );
				break;
			default:
				break;
		}
		
		// Return the class
		return result;
	}

}
