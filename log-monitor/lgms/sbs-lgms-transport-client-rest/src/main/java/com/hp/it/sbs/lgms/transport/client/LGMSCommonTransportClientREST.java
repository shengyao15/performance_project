package com.hp.it.sbs.lgms.transport.client;

import com.hp.it.sbs.core.client.SBSHttpClientExecutor;
import com.hp.it.sbs.core.client.TransportClientImplementation;
import com.hp.it.sbs.core.client.beans.ServiceAPI;
import com.hp.it.sbs.core.client.beans.ServiceAuthentication;
import com.hp.it.sbs.core.client.beans.ServiceRequest;
import com.hp.it.sbs.core.client.interfaces.SharedBusinessService;
import com.hp.it.sbs.core.client.interfaces.SharedBusinessServiceServerResource;
import com.hp.it.sbs.core.client.logging.ClientActivity;
import com.hp.it.sbs.core.client.logging.ClientActivityTracker;
import com.hp.it.sbs.core.shared.exceptions.CoreServiceException;
import com.hp.it.sbs.core.shared.serialization.ObjectMapperProvider;

import java.net.ConnectException;
import java.net.MalformedURLException;
import java.net.SocketTimeoutException;
import java.net.URL;

import org.jboss.resteasy.client.ClientResponse;
import org.jboss.resteasy.client.ProxyFactory;
import org.jboss.resteasy.plugins.providers.RegisterBuiltin;
import org.jboss.resteasy.spi.ResteasyProviderFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * SharedBusinessService Transport Client
 * Service Category:      LGMS
 * Generated By:          sbs-generator
 * Service Version:       1.0.0-SNAPSHOT
 * Core Version:          1.1.2
 * I-Processor Version:   2.1.5
 *
 * This class is generated based upon one of the service's interface(s).
 * The versions listed above were utilized in the process.
 * These may be snapshots instead of actual releases during development.
 */
final class LGMSCommonTransportClientREST extends TransportClientImplementation implements SharedBusinessService
{
	/** Transport Client Logger */
	private static final Logger SERVICELOG;

	/** Service Category */
	public static final String SERVICE_CATEGORY = "LGMS";
	
	/** Service Interface */
	public static final String SERVICE_INTERFACE = "SharedBusinessService";
	
	/** Service Version: Major */
	public static final String VERSION_MAJOR = "1";
	
	/** Service Version: Minor */
	public static final String VERSION_MINOR = "0";
	
	/** Service Version: Incremental */
	public static final String VERSION_INCREMENTAL = "0";
	
	/** Client Timeout: Connection Timeout(ms) */
	private static final int CLIENT_CONNECTION_TIMEOUT = 30000;
	
	/** Client Timeout: Read Timeout(ms) */
	private static final int CLIENT_READ_TIMEOUT = 60000;

	/** String Literal: SUPPRESS_UNCHECKED - string literal to suppress unchecked exceptions (Conditional) */
	@SuppressWarnings( "unused" )
	private static final String SUPPRESS_UNCHECKED = "unchecked";
	
	
	
	/** Client HTTP Executor - client that handles connections to the server implementation */
	private SBSHttpClientExecutor SharedBusinessServiceHttpExecutor;
	
	/** Server Resource Connection - provides connection to the server implementation */
	private SharedBusinessServiceServerResource SharedBusinessServiceResource;
	
	/** HTTP Client Connection Timeout */
	private Integer connectionTimeout = CLIENT_CONNECTION_TIMEOUT;
	
	/** HTTP Client Socket Timeout */
	private Integer socketTimeout = CLIENT_READ_TIMEOUT;
	
	
	
	/** 
	 * This is here because we want to get the RestEasy setup done once, and only once per JVM.
	 * This prevents concurrency conflicts when multiple clients are created (either dynamically by thread, or 
	 * as part of a normal construction)
	 */
	static
	{
		// Only swap the class loader when running in IKVM's .NET JVM
		if( System.getProperty("java.runtime.name").equals("IKVM.NET") ) {
			// Setup the contextual class loader for the thread before anything from RESTEasy is instantiated
			// Inner classes utilize Class.forName() which causes an issue if the wrong context loader is present
			// Note: This is included for supporting .NET Clients converted through IKVM
			String oldCLName = Thread.currentThread().getContextClassLoader().toString();
	        Thread.currentThread().setContextClassLoader( LGMSCommonTransportClientREST.class.getClassLoader() );
	        String newCLName = Thread.currentThread().getContextClassLoader().toString();
	        
	        // Now instantiate the logger and make note of the modifications made to the class loader
	        SERVICELOG = LoggerFactory.getLogger(LGMSCommonTransportClientREST.class);
	        SERVICELOG.info( "Context Class Loader changed from \"{}\" to \"{}\"", oldCLName, newCLName  );
		} else {
			// Otherwise only instantiate the logger
	        SERVICELOG = LoggerFactory.getLogger(LGMSCommonTransportClientREST.class);
		}
	
		// Register the RESTEasy Provider Factory
		registerProviderFactory();
	}
	
	/**
	 * <b>Register Provider Factory</b><br/>
	 * Registers the provider factory for RESTEasy<br/>
	 * This will be provided to the client for handling conversions<br/>
	 */
	private static final void registerProviderFactory( )
	{
		// Acquire an instance of the RESTEasy Provider
		ResteasyProviderFactory resteasyProvider = ResteasyProviderFactory.getInstance();
		
		// Register the provider
		RegisterBuiltin.register(resteasyProvider);
		
		// Register any providers
		registerProviders(resteasyProvider);
		
		// Register any readers
		registerMessageBodyReaders(resteasyProvider);
		
		// Register any providers
		registerMessageBodyWriters(resteasyProvider);
	}
	
	/**
	 * <b>Register Providers</b><br/>
	 * Registers individual providers needed by the RESTEasy factory<br/>
	 * Each is responsible for a different Java type<br/>
	 * @param factory RESTEasy Provider Factory
	 */
	private static final void registerProviders( final ResteasyProviderFactory factory )
	{
		// Provider to handle converting SBS Objects
		factory.registerProvider(ObjectMapperProvider.class);
		
		// Provider to handle converting JSON
		factory.registerProvider( org.jboss.resteasy.plugins.providers.jackson.ResteasyJacksonProvider.class);
		
		// Provider to handle converting strings
		factory.registerProvider( org.jboss.resteasy.plugins.providers.StringTextStar.class );
		
		// Providers to handle content encoding
		factory.registerProvider( org.jboss.resteasy.plugins.interceptors.encoding.AcceptEncodingGZIPInterceptor.class );
		factory.registerProvider( org.jboss.resteasy.plugins.interceptors.encoding.GZIPDecodingInterceptor.class );
	}
	
	/**
	 * <b>Register Message Body Readers</b><br/>
	 * Registers individual message body readers needed by the RESTEasy factory<br/>
	 * Each is responsible for a different Java type<br/>
	 * @param factory RESTEasy Provider Factory
	 */
	private static final void registerMessageBodyReaders( final ResteasyProviderFactory factory )
	{
		// Register message body readers for RESTEasy
		factory.addMessageBodyReader(org.codehaus.jackson.jaxrs.JacksonJsonProvider.class);
		factory.addMessageBodyReader(org.codehaus.jackson.jaxrs.JacksonJaxbJsonProvider.class);
		factory.addMessageBodyReader(org.jboss.resteasy.plugins.providers.jackson.ResteasyJacksonProvider.class);
	}
	
	/**
	 * <b>Register Message Body Writers</b><br/>
	 * Registers individual message body writers needed by the RESTEasy factory<br/>
	 * Each is responsible for a different Java type<br/>
	 * @param factory RESTEasy Provider Factory
	 */
	private static final void registerMessageBodyWriters( final ResteasyProviderFactory factory )
	{
		// Register message body writers for RESTEasy
	}


	/**
	 * Authenticated Constructor
	 * Configures the RESTEasy provider
	 * Caches the authentication information
	 * Acquires the current logging level
	 * @param authentication Service Authentication Information
	 */
	public LGMSCommonTransportClientREST( final ServiceAuthentication authentication )
	{
		// Client Implementation Constructor
		super();
		
		// Set the authentication information
		setCachedAuthentication( authentication );
		
		// Generate the service url
		serviceURL = generateURL(
					serviceLifecycle,
					SERVICE_CATEGORY,
					SERVICE_INTERFACE,
					VERSION_MAJOR,
					VERSION_MINOR,
					VERSION_INCREMENTAL );
					
		// Initialize the client
		initialize();
	}
	
	/**
	 * <b>Get HTTP Client Connection Timeout</b><br/>
	 * The timeout until a connection is established<br/>
	 * A value of zero means the timeout is not used<br/>
	 * @return duration Milliseconds (ms)
	 */
	public Integer getConnectionTimeout( )
	{
		return this.connectionTimeout;
	}
	
	/**
	 * <b>Get HTTP Client Socket Timeout</b><br/>
	 * Sets the socket timeout (SO_TIMEOUT) in milliseconds to be used when executing the method<br/>
	 * A timeout value of zero is interpreted as an infinite timeout<br/>
	 * @return duration Milliseconds (ms)
	 */
	public Integer getSocketTimeout( )
	{
		return this.socketTimeout;
	}
	
	/**
	 * <b>Set HTTP Client Connection Timeout</b><br/>
	 * The timeout until a connection is established<br/>
	 * A value of zero means the timeout is not used<br/>
	 * @param duration Milliseconds (ms)
	 */
	public void setConnectionTimeout( final Integer duration )
	{
		// Must be positive
		if( duration >= 0 ) {
			SERVICELOG.info( "Client Connection Timeout: " + duration );
			this.connectionTimeout = duration;
			
			// Update the HTTP Executor
			this.SharedBusinessServiceHttpExecutor.setConnectionTimeout( this.connectionTimeout );
		}
	}
	
	/**
	 * <b>Set HTTP Client Socket Timeout</b><br/>
	 * Sets the socket timeout (SO_TIMEOUT) in milliseconds to be used when executing the method<br/>
	 * A timeout value of zero is interpreted as an infinite timeout<br/>
	 * @param duration Milliseconds (ms)
	 */
	public void setSocketTimeout( final Integer duration )
	{
		// Must be positive
		if( duration >= 0 ) {
			SERVICELOG.info( "Client Socket Timeout: " + duration );
			this.socketTimeout = duration;
			
			// Update the HTTP Executor
			this.SharedBusinessServiceHttpExecutor.setSocketTimeout( this.socketTimeout );
		}
	}
	
	/**
	 * Get SharedBusinessService
	 * @return SharedBusinessServiceResource
	 */
	protected SharedBusinessServiceServerResource getSharedBusinessServiceResource( ) 
	{
		return this.SharedBusinessServiceResource;
	}

	/**
	 * Set SharedBusinessService
	 * @param serverResource Server Resource Object
	 */
	protected void setSharedBusinessServiceResource( final SharedBusinessServiceServerResource serverResource )
	{
		this.SharedBusinessServiceResource = serverResource;
	}
	
	/**
	 * Initialize
	 * Determines the life cycle
	 * Acquires the SharedBusinessServiceResource
	 */
	private synchronized void initialize( )
	{
		// Check if the service resource needs to be created
		if ( this.SharedBusinessServiceResource == null )
		{
			// Start tracking the activity
			ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_INITIALIZE);
			
			this.SharedBusinessServiceHttpExecutor = null;
			try {
				// Attempt to break the Service URL into parts
				URL sbsURL = new URL( serviceURL );
				
				// Create an HTTP executor for calling services
				this.SharedBusinessServiceHttpExecutor = new SBSHttpClientExecutor(
					sbsURL.getHost(),
					sbsURL.getPort(),
					sbsURL.getProtocol(),
					CLIENT_CONNECTION_TIMEOUT,
					CLIENT_READ_TIMEOUT
				);
			} catch ( MalformedURLException e ) {
				// Track the error
				SERVICELOG.error( e.getMessage(), e );
				
				// Create an HTTP executor for calling services
				this.SharedBusinessServiceHttpExecutor = new SBSHttpClientExecutor(
					CLIENT_CONNECTION_TIMEOUT,
					CLIENT_READ_TIMEOUT
				);
			}
			
			// Create a server resource with the executor
			SharedBusinessServiceServerResource SharedBusinessServiceResourceTemp =
					ProxyFactory.create(
						SharedBusinessServiceServerResource.class,
						this.serviceURL,
						this.SharedBusinessServiceHttpExecutor
					);
			
			// Save the resource for later usage
			setSharedBusinessServiceResource( SharedBusinessServiceResourceTemp );
			
			// Stop tracking the activity
			ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_INITIALIZE);
		}
	}

	/**
	 * Initialize ServiceRequest
	 * @return Service Request
	 */
	private ServiceRequest generateServiceRequest( ) {
		// Start tracking the activity
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_CREATE_REQUEST);
		
		// Create a new service request
		ServiceRequest request = new ServiceRequest();
		
		// Initialize the service request
		initializeRequest(request);
		
		// Stop tracking the activity
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_CREATE_REQUEST);
		
		// Return the service request
		return request;
	}

	/**
	 * {@inheritDoc}
	 * @see com.hp.it.sbs.core.client.interfaces.SharedBusinessService#healthCheck SharedBusinessService
	 */
	public String healthCheck(  )
	{
		// Setup the return object
		String result = null;
		
		// Initialize the service request
		ServiceRequest request = generateServiceRequest( );

		// Start tracking the execution of healthCheck()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_SEND_REQUEST);
		
		// Client Response Object
		ClientResponse<?> clientResponse = null;
		
		try {
			// Execute the service call
			clientResponse = getSharedBusinessServiceResource().healthCheck(request);
		} catch ( RuntimeException sbsServiceException ) {
			if( sbsServiceException.getCause() instanceof SocketTimeoutException ) {
				// Set a unsuccessful status code since an exception was thrown
				SBSLOGGER.error( SOCKET_TIMEOUT, serviceURL, sbsServiceException.getMessage());
			} else if ( sbsServiceException.getCause() instanceof ConnectException) {
				// Set a unsuccessful status code since an exception was thrown
				SBSLOGGER.error( CONNECTION_REFUSED, serviceURL, sbsServiceException.getMessage());
			} else {
				// Set a unsuccessful status code since an exception was thrown
				SBSLOGGER.error( RUNTIME_ERROR, sbsServiceException.getMessage());
			}
			
			// Capture the exception to be thrown after logging & processing
			throw new CoreServiceException( sbsServiceException );
		}
		
		// Stop tracking the execution of healthCheck()
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_SEND_REQUEST);
		
		// Retrieve the return object from the service response
		result = this.<String>processResponse( clientResponse );

		// Return the response to healthCheck()
		return result;
	}
	
	/**
	 * {@inheritDoc}
	 * @see com.hp.it.sbs.core.client.interfaces.SharedBusinessService#getServiceAPI SharedBusinessService
	 */
	public ServiceAPI getServiceAPI(  )
	{
		// Setup the return object
		ServiceAPI result = null;
		
		// Initialize the service request
		ServiceRequest request = generateServiceRequest( );

		// Start tracking the execution of getServiceAPI()
		ClientActivityTracker.startFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_SEND_REQUEST);
		
		// Client Response Object
		ClientResponse<?> clientResponse = null;
		
		try {
			// Execute the service call
			clientResponse = getSharedBusinessServiceResource().getServiceAPI(request);
		} catch ( RuntimeException sbsServiceException ) {
			if( sbsServiceException.getCause() instanceof SocketTimeoutException ) {
				// Set a unsuccessful status code since an exception was thrown
				SBSLOGGER.error( SOCKET_TIMEOUT, serviceURL, sbsServiceException.getMessage());
			} else if ( sbsServiceException.getCause() instanceof ConnectException) {
				// Set a unsuccessful status code since an exception was thrown
				SBSLOGGER.error( CONNECTION_REFUSED, serviceURL, sbsServiceException.getMessage());
			} else {
				// Set a unsuccessful status code since an exception was thrown
				SBSLOGGER.error( RUNTIME_ERROR, sbsServiceException.getMessage());
			}
			
			// Capture the exception to be thrown after logging & processing
			throw new CoreServiceException( sbsServiceException );
		}
		
		// Stop tracking the execution of getServiceAPI()
		ClientActivityTracker.endFrameworkActivity(ClientActivity.CLIENT_ACTIVITY.CLIENT_SEND_REQUEST);
		
		// Retrieve the return object from the service response
		result = this.<ServiceAPI>processResponse( clientResponse );

		// Return the response to getServiceAPI()
		return result;
	}
	
}
